OST等中均有广泛应用如make_shared(),make_tuple()…,在日常开发中,一般会在工厂类内部进行创建对象的相关逻辑判断,生成对应的对象.优点:创建对象接口统一,不同的功能之间解耦合,扩展性好.

2:策略模式
	定义:定义了算法家族.分别封装起来,让它们之间可以互相替换,此模式让算法变化,不会影响到使用算法的用户.
	如果说简单工厂模式是对不同对象之间的集中管理,策略模式更像是对各种算法,计算方法的包装设计,具体实现过程也很相似.更具体的是关于用户代码,程序代码,代码逻辑,业务的划分.暂时没有发现它们俩的具体区别,留后记.

3.单一职责原则
	设计模式或者面向对象讲究的是:可扩展,可复用,可维护,灵活性好.解耦的关键就在于对代码逻辑,业务的划分.最常见的界面与后台逻辑处理分开,不同功能的模块分开,以达到强内聚,松耦合.难点就在于发现职责并把那些职责相互分离.

4.开放封闭原则
	定义:实体软件(类,模块,函数等等)应该可以扩展,但是不可以修改.
	单一职责原则是对程序整体设计或者类设计进行规划方面的原则,具体到具体类,模块,函数等的内部设计,在最初设计时应该尽量预期的变化,将变化的部分进行抽象抽离,后续设计尽量不要更改现有逻辑设计体系,做扩展优于更改现有代码.但是凡是无绝对,初期的设计难免会有逻辑缺陷或者对未来变化预估的缺失,所以应做到发现变化时,及时对类的设计进行动态变化设计.

5.依赖倒转原则
	定义:抽象不应依赖细节,细节应该依赖于抽象.也就是针对接口编程而不要对实现编程.具体有以下两方面的意义:
A:高层模块不应该依赖底层模块.两个都应该依赖抽象.
B:抽象不应该依赖细节.细节应该依赖抽象.
也就是编写时考虑到的是如何针对抽象编程而不是针对细节编程.

6.装饰模式
	定义:动态地给一个对象添加一些额外的职能,就增加功能来说,装饰模式比生成子类的方式更灵活.
	比如你有很多功能要加到一个对象里面,功能的种类有很多,组合方式就更多,而且加的顺序可能也有一定的要求,那么此时装饰模式可以解决此类问题,而且扩展性较好.
	具体实现,一般会有一个所有类都需要继承的底层虚基类,装饰类继承该基类,该装饰类内会有一个装饰方法,用于对基类对象进行加装饰.同时具体的不同方法或操作会被实例化为许多装饰类的子类,利用子类之间的循环嵌套完成装饰操作,最终所有装饰上的方法通过调用父类方法的方式进行循环解套调用.注意方法的调用顺序与装饰的顺序是相反的,如其名装饰模式和穿衣服脱衣服的顺序一样的.

7.代理模式
	定义:为其它对象提供一种代理以控制对这个对象的访问.
	直观从定义上来看,应该是对一个类的包装,所有方法调用通过代理类来进行,例如假想类分两种,一种只能放成员变量,另一种只能放成员方法,那么只能放方法的类就可以看做是只能放成员变量类的代理.
	具体实现,能够代理某一个类本质上应该是一种封装的特性,为了能够简便实现一般代理类与被代理类会实现相同的接口,在代理类当中会有被代理类的一个引用,则代理类中的方法会直接调用被代理类对应的方法.
	代理模式作为一种极佳的封装方式,广泛地应用于实际系统设计当中,例如:加载网页中的虚拟代理,加载网页时慢慢显示出来的图片就是虚拟代理类对象处理的效果;安全代理,利用不同的代理类对一些管理权限比较高的类进行封装,以达到设置不同权限的需求.

8.工厂方法模式
	定义:一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使一个类的实例化延迟到其子类.
	简单工厂模式的最大优点是工厂类内包含生成对象的逻辑,利用简单的对象标识生成对应的子类.工厂方法模式则是取消工厂类内的逻辑判断,增加每一个对应子类的工厂方法类用于直接生成对应功能子类.解决了简单工厂模式在增加新的功能子类的同时也需要修改工厂类内的逻辑代码的缺陷,取而代之的是增加新的功能子类和对应工厂方法子类即可.对扩展开放,对修改封闭.
	工厂方法模式更适合对子类(产品)能够分类,不同类的子类(产品)利用不同的工厂方法类生成,克服了简单工厂模式违背开放-封闭原则的缺点,又保持了封装对象创建过程的有点.

9.原型模式
	定义:用原型实例指定创建对象的种类,并通过拷贝这些原型创建新的对象.
	在JAVA中可能没有拷贝构造的概念,所以原型模式更像是此类弱类型语言中的拷贝构造或者拷贝复制函数.同样在两种模式中都存在浅拷贝与深拷贝的问题.是拷贝原始数据(深拷贝),还是只拷贝引用(浅拷贝)应该注意.以及memberwise概念都对对象模式产生影响.c++中此类问题可能偏少,直接定义类自己的拷贝构造函数,并在拷贝构造中控制对应成员变量的拷贝方式即可.

10.模板方法模式
	定义:定义一个操作中的算法骨架,而将一些步骤延迟到子类中.模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤.
	此模式更能体现面向对象的精髓,从对方法或算法的封装,到分析算法中的变与不变,运用多态与继承将不变的部分抽象到基类,变化的部分在基类中成为虚函数,并在子类中对变化的部分进行重载,最终完成可扩展,易复用,灵活性好的设计需求.
	当不变的和可变的行为在方法的子类实现中混为一潭时,不变的行为会在子类中重复出现.利用模板方法类将不变的方法提取到子类中摆脱不变行为的纠缠.

11.迪米特法则
	定义:如果两个类不必要直接通信,那么这两个类就不应该发生直接相互作用.如果其中一个类需要调用另一个类的某一个方法,可以通过第三方进行转发.
	具体如下:在类的结构设计上,尽量提高访问类的内部成员的权限要求,也就是尽量做到更严格的封装.本质上迪米特法则体现的是封装上的松耦合,同时体现强内聚.

12.外观模式
	定义:为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口,这个接口使得这一子系统更加容易使用.
	从uml图来看,外观模式是将底层的一组类似的功能算法封装起来提供统一的对外接口供上层架构调用,对客户端隐藏底层功能算法的实现以及调用方法.是依赖倒转原则以及迪米特法则的重要体现.
	代理模式如果是对具体某个类的代理或者二次封装,外观模式更像是对一类相似类的集中代理并提供统一的对外调用接口.对于难以直接进行扩展的老旧架构或系统同样可以利用外观模式进行封装,对外输出调用接口,以便进行进一步地新功能扩展而不改变现有体系.

13.建造者模式
	定义:将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.
	对于某些复杂的类,它的构建需要遵循一定的步骤或者必须有某些步骤,那么如果在客户端的代码中手动构建这些类就需要写出很多步骤,同时容易出错,此时应该将这些类创建步骤进行抽象处理,然后利用辅助类来完成创建过程,并直接给出所需要创建的类对象.
	创建模式的好处是使得创建对象的代码与表示代码分离.由创建对象的辅助类来提供对象实例.感觉更像是间接在has-a的类当中完成不同类的创建并直接返回该包含类的对象实例.书上的实现感觉略有复杂,直接在抽象基类中定义构造函数,构造函数中调用当前基类中的类对象创建步骤虚函数,所有特有子类继承该抽象基类,并重载各自的创建步骤即可,那么再利用一个工厂函数就可以完成所有不同类的直接创建,封装更加严格.同样也可以在子类中添加特有的创建步骤,只需要将基类的构造函数改为调用一个成员虚函数,在该虚函数内部完成对象创建步骤,并在子类中加入新的创建步骤即可.

14.观察者模式(发布-订阅模式)
	定义:一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象.这个主题对象在状态发生改变时,会通知所有观察者对象,使它们能够自动更新自己的状态.
	类似于报刊业务,所有的报纸在印刷出来以后会直接寄到所有的订阅者手中,不同的订阅者在得到同一份信息(报纸)之后会有不同的动作.类似的一对多的应用场景是观察者模式的舞台.
	对模型进行抽象:建立抽象观察者基类以及抽象通知者基类,并建立对相应的基类.在通知者基类中会有所有其管理的观察者基类的引用的集合,当事件发生时,利用成员函数通知所有的观察者(一般是利用多态直接调用观察者的成员(更新)函数).缺点:观察者与通知者的耦合是提前设定的,且一个通知者管理的所有的观察者的更新函数应该是继承体系中的同一个函数,灵活性比较差.
	加强版的事件委托方式灵活性更好.首先将通知类中的观察者引用集合更换为所有观察者更新函数的函数指针类型,或者仿函数类型集合.那么在客户端代码中,创建观察者对象并与通知者设置关联时,采用在对应通知者的可调用对象集合中添加该观察者对象的更新函数即可.但需要函数类型(传入参数,返回参数)保持一致.这样的话观察者基类就不需要了,灵活性更好,C#或者其他语言中有现成的事件委托设计可以直接使用,c++可能需要自己手动设置可调用函数集合,并在通知者内部调用这些函数(可能需要对象模式中的成员函数指针,对象指针等).

15.抽象工厂模式
	定义:提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类.
	普通工厂模式是用一个工厂类或工厂函数负责所有的类的生成,对象生成逻辑在工厂类内部;工厂方法模式是一个工厂基类负责一个对象的生成,对象生成逻辑在客户端,手动选择不同工厂类或者工厂函数生成对应的类;抽象工厂模式是一个工厂基类负责一类抽象对象的生成,是对工厂方法模式的扩展,增加每个工厂类的管理类数量,现在是类簇.
	正如上面所说,这三者互有优缺,普通工厂调用形式简单,工厂方法封装更好,抽象工厂扩展性更好.如何去综合三者的优点是值得讨论的问题,首先,抽象工厂类在创建不同工厂类时可以选择采取普通工厂模式以及工厂方法模式,但是普通工厂模式的逻辑判断在工厂类内部,不符合开放封闭原则,修改的地方过多.利用反射技术可以解决这种缺点.反射技术个人感觉是类似与matlab等脚本语言中的eval的功能,动态地在运行时控制对象的生成类型,将能够以配置文件形式的信息,在运行控制对象的生成以及代码的逻辑.java有自带的反射机制功能强大,也很方便,对于c++这种强类型语言其实是比较麻烦的,需要手动建立类似对象名到构造函数指针的映射,在运行时解析.总之反射+配置文件可以解决普通工厂模式当中需要switch或逻辑判断的缺点.

16.状态模式
	定义:当一个对象的内在状态改变时允许改变其行为,这个对象看起来就好像是改变了其类型.
	对于一些类肯能定义了一些状态属性,并且这些状态属性会随着时间或者其他条件变化,那么控制状态变化的逻辑代码可能比较复杂,这样的话是不满足开放封闭原则,此时应该将不同的状态封装成类,并在各自的类中控制逻辑的转换.

17.适配器模式
	定义:将一个类的接口转换成客户希望的另外的接口.adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.
	顾名思义,适配器模式更多的作用是对现有类或者代码的重新封装,使其符合客户端需要的对外接口.同样也可以用于类功能的转发或者升级,类似于做了一个封装和包装,stl标准库中stack,queue也是适配器的例子,以stack为例,stack在deque的基础上进行封装,修改其接口满足后进先出的规则,并实现stack所需的push,pop,top等函数,是对现有代码的极大重用.
	不同于stack,现实开发中更多的应用可能是对现有程序架构或者类的修改,其实这反应的是前期类的设计或者架构设计的缺陷,所以初期开发应该尽量避免此类设配应用,开发中期如果能够通过代码重构,将接口进行重新设计或者统一,后期当代码已经比较复杂时,通过适配器模式进行统一接口是可以.所以任何模式都不应该盲目滥用,合理的布局和使用各种模式才是正确的.

18.备忘录模式
	定义:在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样就可以在以后需要的时候直接恢复原来的状态.
	其实如果直接完成上述的功能只需要该类含有拷贝构造函数,拷贝赋值函数即可,备份意即直接通过拷贝构造创建一个备份对象,过后再通过赋值操作恢复状态.但是如果拷贝构造需要大量的工作时,这种处理性能比较低,而且对象的状态保存可能只需要一小部分的信息,而其它信息保持不变,此时就必须利用备忘录模式进行备份恢复工作.
	在需要备份的类内设计备份和恢复的成员函数,其函数传入参数一般是状态信息,状态信息一般会在备份类内含有同样的一份实例,在需要备份函数内生成备份类对象,在恢复函数内部通过备份类恢复状态.同样可以设计管理备份类的类,利用工厂模式或者其它模式进行不同种类备份的管理.


19.组合模式
	定义:将对象组合形成树形结构以表示”部分-整体”的层次结构.组合模式使得用户对单个对象和组合对象的使用具有一致性.
	相当于是建立类似于总公司(子公司1(人力部门,财务部门...),子公司2(...),人力部门,财务部门...)这种结构,并且对于用户来说,不论对总公司,子公司,人力部门… 的调用接口是一样的.此时需要组合模式来进行组合.
	首先既然所有的公司,以及部门需要统一的对外接口,那么其公共部分就要抽象到基类中,所有的部件派生自该基类.类似于公司的这种组合类,其内部含有含有许多同样的子类,所以需要建立基类的集合来表示其组合部件,并且其对应函数的调用,需要循环调用所有子类的方法.对于普通的单纯职能类,则只需要单纯将对应函数实现出来即可.表现在树形结构上来看,公司这种组合型子类相当于含有子节点的节点,而普通的职能子类则相当与叶子节点.总结起来就是,利用统一的抽象对象代表所有的类,借由集合的形式构建树形结构,利用迭代递归调用完成组合类的函数调用.

20.迭代器模式
	定义:提供一种方法顺序访问一个聚合对象中各个元素,而又不暴露该对象的内部表示.
	将对一个聚合对象的访问与具体聚合对象实现分离开来,在迭代器内部实现遍历聚合对象所需的一些接口,且访问时不需要关心聚合类的内部实现.由于该功能的用处很大,基本上现有的面向对象语言都已经对内部聚合类型实现了迭代器访问,通过迭代器与泛型编程可以极大地提高开发效率以及开发质量.分离了集合对象的遍历行为,抽象出一个迭代器类来负责,既可以做到不暴露集合的内部结构,又可以让外部代码透明地访问集合内部的数据.

21.单例模式
	定义:保证一个类仅有一个实例,并提供一个访问它的全局访问节点.
	单例模式在实际开发中,用类去表示系统中唯一存在的一个实例是非常有用.单例模式意及只能存在一个该类的实例对象.构造器是负责每个类实例的函数,为了控制类实例化的数量就应该控制函数的调用权限,一般通过将构造函数设为私有化,那么在类的外部是无法直接创建对象的.那么这个唯一的实例对象应该在哪那?一般单例模式需要提供一个全局化的获得实例方法,通过该方法来获得唯一对象,为了方便以及更加紧凑,一般会直接将单例模式的实体直接放在类的内部.
	对于类似于JAVA的语言,优于其支持不完全类型定义,所以在类的内部定义一个静态对象是可以的,只需要保证类内对象只实例化一次即可,而且由于有垃圾回收不用担心内存泄漏的问题.但是可能存在线程不安全的问题,所以需要对实例化代码进行线程安全处理,一般可以直接采用将所有实例化判断逻辑和实例化代码上锁,来满足线程安全处理.但是锁数据资源类型的类,其实例化是比较耗费资源的,当操作次数变多时,会极大影响性能.所以一般采用双重锁定来解决这个问题,先进行逻辑判断,然后上锁,在进行逻辑判断,最后解锁.再之对于支持静态初始化特性的语言,可以有更加简便的处理,无需担心线程安全的问题.
	对于C++,传统方法采用1:私有化构造函数,拷贝构造函数,拷贝赋值函数;2:采用线程安全的机制;3:创建内部静态辅助类释放堆内存.由于c++11的某些特性有了更好的解决方案,对于问题2,c++11支持局部静态变量的初始化线程安全.所以线程安全ok;3上述2中直接采用定义静态变量的问题,不涉及堆内存,同样也可以利用智能指针shared_ptr来解决内存泄漏问题,参考代码如下:
#include <memory>
/////////////////////////终极版
class singtonFin{
public:
    int flag;
    static singtonFin& getInstance(){
        static singtonFin s;//c++11 保证局部静态变量在初始化的时候是线程安全的所以没有问题.
        return s;
    }
private:
    //下面三个是必须要私有或者删除的
    singtonFin(){};
    singtonFin (const singtonFin&);
    singtonFin& operator=(const singtonFin&);
    //static std::shared_ptr<sington> s;
};
///////////////////////////////////////////////////////////////
//下面应该也可以
class sington{
public:
    typedef std::shared_ptr<sington> sType;
    static sington& getInstance(){
        return *s;
    }
private:
    sington(){};
    sington(const sington&);
    sington& operator=(const sington&);
    static sType s;
};
//会在程序运行前面被初始化
sington::sType sington::s=sington::sType(new sington());
上述实例中sington 属于所谓的饿汉模式,即在类解析加载时该类的唯一实例就会被创建,singtonFin 属于懒汉模式为只有当getInstance被调用时才会构建实例各有利弊.一般饿汉的运行效率应该更高一点.

22.桥接模式
  1:合成聚合原则
	定义:尽量使用合成/聚合,尽量不要使用继承.个人理解:合成意及一个类中含有数个不同的类的具体对象,且均为has-a关系;聚合则是一个类内含有一组数个相同类型的类的集合或聚合体.当单纯的继承这种is-a关系使得整个继承体系过于负责或者耦合比较密时,应该考虑采用聚合或合成的关系以消除继承中的血缘关系.
  2:桥接模式
	定义:将抽象部分与它的实现部分分离,使它们都可以独立地变化.
	实例采用手机各种品牌与各种手机软件之间的关系,手机可以按照品牌,软件类别,屏幕类型,等分类,这些性质本质上都可以抽象出来,然后底层的手机类一步步继承上述所有的类,但是这样就会导致继承层数过深,增加代码复用的难度.桥接模式采用将抽象部分与实现部分分离来解决这个问题,也就是将这些看似可以用继承完成的属性,但实际上而是手机有一个品牌,一块屏幕,一些软件,而不是这些.通过将上述属性进行抽象,最后用这些抽象实例的基类来组合成最终的类,并在用户代码中进行这些属性的设置以及调用. 实现系统可能有多角度分类,每一种分类都有可能变化,那么就把这种多角度分离出来让它们独立变化,减少它们之间的聚合.

23.命令模式
	定义:讲一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志,以及支持可撤销的操作.
	实例采用烤肉店的例子,烤肉店中顾客并不是像街边烤肉店一样直接交互,服务员会记录顾客所有点的单,然后去厨房通知厨房去做不同的食品,不同的食品也可能是不同的师傅做的.但是实现起来可能是令人琢磨不清的,最最重要的是这里将服务员向厨房传递的信息抽象为命令,服务员负责对这些命令进行记录,告之后台等.
	优点:1.能够容易的实现一个消息队列;2:在需要的情况下,可以较容易地将命令计入日志;3:允许接收方是否否决请求;4支持队请求的重做和撤销;5:由于加紧新的具体命令类不会影响其他的类,因此增加新的具体命令类也很容易.命令模式把请求一个操作的对象与知道怎么执行一个操作分割开.

24.职责链模式
	定义:使多个对象都有机会处理请求,从而避免请求的发送方和接受者之间的耦合关系.将这个对象连成一条链,沿着这条链传递该请求,直到有一个对象处理它.这样系统的更改可以在不影响客户端的情况下动态地重新组织和分配责任.
	实例采用加薪申请来说明,不同级别的管理者有不同级别的加薪审批权,如果是过程式的程序设计,会在申请审批是有很长的条件判断,而且有新的管理者加进来是都需要更改次逻辑,耦合度过高.所以最先想到的就是将这些管理者进行抽象,但是单纯的抽象并不能体现出职责链的层层递进,权限逐级递增的关系,所以在类内部设置了该管理者的直接后继负责请求的后续处理.
	具体实现:将所有管理层级上的类进行抽象,抽象内含有一个设置直接后继,以及请求处理函数,该函数接受一个申请类的对象.在客户端中创建所有的管理类的对象并设置每个管理类的直接后继,然后直接调用管理底层对象的请求处理函数,如果该管理者可以处理该请求就会直接处理,否则该管理者会直接调用后继的请求处理函数.这样的设计灵活性更好,且各个管理者之间的耦合性较低.

25.中介者模式
	定义:用一个中介对象来封装一系列的对象交互.中介者使各对象不需要显示的互相调用,从而使其耦合松散,可以独立地改变他们之间的交互.
	实例采用联合国的只能与协调各国的关系来说明,联合国成立以前各国可能都是采用直接的相互沟通解决国际关系,关系网错综复杂,联合国成立之后,有关大事或者无直接沟通渠道的国家可以通过联合国来进行双方
的交流,联合国在这里扮演的就是一个中介者的角色,通过其相互协调,降低了各个国家之间的耦合程度.这样的处理可以使系统的灵活性更好,耦合更低.
	具体实现,抽象各个待管理类,抽象中介者类,在中介者类中有其协调的所有对象的实例,在待管理类中有其中介的实例化对象,所有的管理类请求代由中介者类执行,中介者类判断该请求的接收方,调用该接受方的相关方法进行应答.
	中介者模式将多对多的关系解耦形成了多对一的关系,但是同时加大了中介类的管理负担,以及请求转发的复杂性,不过其在解耦上的优势还是很明显的.中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合,以及想定制一个分布在多个类中的行为,而又不想产生太多的子类的场合.

26.享元模式
	定义:运用共享技术有效地支持大量细度的对象.
	实例采用类似于博客网站的设计,日常我们访问的博客网站,对于每个人来说都像一个各人网站,按理说如果是不同的网站肯定是每个网站都有自己的设计,但是对于这种形式差不多的网站再单独设计是不合适的.享元模式是一种对象共享技术,如果系统中含有大量的类似的类需要实例化,这些实例化的对象将会占据大量的系统内存.但是如果我们将这些类当中的不变的内容放到一个单独的类中,所有需要该类的地方可以使用引用或者指针的方式直接调用.
	具体实现:将需要共享的类进行抽象,相同的部分放到一个对象中,然后所有需要该类的地方以引用或者指针代替.当需要共享的类不是太多时们,可以增加抽象类对象的数量,以满足迅捷开发的需求,只需要在利用普通工厂模式,或者工厂方法模式进行管理即可.例如:标准库中的string,基本上都是以享元模式建立的,对于相同内容的string对象,会建立string的内存池,如果要生成的string对象,内存之内已有,则不会生成那个对象,两个变量引用到的是同一块内存.

27.解释器模式
	定义:给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子.
	如果一种特定类型的问题发生的频率足够高,那么可能就值得将该问题的各个实例表述为一个简单语言中的句子.这样就可以构建一个解释器,该解释器通过解释这些句子来解决该问题.正则表达式就是解释器模式的一种应用,通过正则表达式语法构建正则匹配表达式,然后利用文法解释器来判断是否匹配.
	一般会将各种语法解释器先进行抽象,然后派生出一系列的文法解释器,客户端中会利用循环逐步分解解释所写词法,然后直接用机器熟悉的语法执行出来.

28.访问者模式
	定义:表示一个作用于某对象结构中的各个元素的操作.它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作.
	其实只是顺理成章的想法,不同的对象可能有类似的操作,如果是结构化语言的设计,那么就会是洪水一样的一连串helloworld,耦合性太强,违反开放封闭原则,所以最先想到的就是将这些不同的对象抽象到一个基类里面,然后在各个基类里面调用不同的行为方法,但是这样就会有一个问题就是当需要增加新的行为或者动作时需要将所有对象进行改动,耦合性较强,此时自然会想到直接将这些行为动作抽象出来,那么只需要在行为动作类当中对不同的对象定义不同的行为,这样当对象的种类确定或者变化频率较低时,就可以实现快速的增加新的行为动作.
	具体实现,建立各类对象的抽象基类,并在基类内部提供一些共有的调用接口;建立抽象行为基类,提供对不同子对象的调用接口,各个派生类行为基类重载实现各自的行为函数.建立各自的基类对象,在基类对象内部实现调用不同行为函数的调用接口.由于各类对象的形式以及种类是固定的,所以将变化的部分放到了行为类的内部,这样增加新的行为是只需要实现具体的对象调用行为函数即可.但是正如上述思路的思考过程,访问者模式适合于对象种类固定且比较少的情况下,能够将变化封装在行为类内部,但是当对象发生变化时需要改动所有的行为类,这是非常困难的.





